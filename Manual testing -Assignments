Manualtesting questions 

1. Write 3 examples explaining importance of testing?

	It helps detect UI, usability, and functional issues that automation might miss.
    It‚Äôs essential for critical areas like payments, checkout flows, and mobile app behavior.

2. Write main difference between QA & QC? Where QA is applicable & where QC is applicable?    
| Aspect              | QA (Quality Assurance)                                                 | QC (Quality Control)                                                  |
| ------------------- | ---------------------------------------------------------------------- | --------------------------------------------------------------------- |
| **Definition**      | Process-oriented ‚Äì ensures proper processes to build quality software. | Product-oriented ‚Äì ensures the final product meets quality standards. |
| **Focus**           | Preventing defects.                                                    | Finding defects.                                                      |
| **When applicable** | During **software development process**.                               | During **testing and after build completion**.                        |



3.What is a Software Defect?
A software defect (bug) is a mismatch between the expected result and the actual result in the application.
It means the software does not behave as intended according to requirements.

4. Write a template for Test case.

| Field               | Description                               |
| ------------------- | ----------------------------------------- |
| **Test Case ID**    | Unique ID (e.g., TC_001)                  |
| **Test Scenario**   | Brief description of what is being tested |
| **Preconditions**   | Setup or conditions required before test  |
| **Test Steps**      | Steps to perform the test                 |
| **Expected Result** | What should happen                        |
| **Actual Result**   | What actually happened                    |
| **Status**          | Pass / Fail                               |
| **Comments**        | Additional notes (if any)                 |


5. Explain STLC. - Software Testing Life Cycle

STLC defines the sequence of steps to ensure software quality.
Phases:

Requirement Analysis

Test Planning

Test Case Design

Test Environment Setup

Test Execution

Defect Reporting

Test Closure

üß† It ensures testing is systematic and traceable.


6. Advantages of Agile over Waterfall Model

Agile is iterative & flexible, while Waterfall is linear & rigid.

Agile allows frequent feedback and early defect detection.

Working software is delivered in short cycles (sprints).

Encourages collaboration and adaptability to change.


7. Difference between SDLC and STLC ?

Aspect	    SDLC	                                                STLC
Full Form	Software Development Life Cycle               	        Software Testing Life Cycle
Focus	    Covers the entire development process	                Focuses only on testing phase
Stages	    Requirement ‚Üí Design ‚Üí Coding ‚Üí Testing ‚Üí Deployment	Requirement ‚Üí Test Planning ‚Üí Execution ‚Üí Closure
Goal	    Build the product	                                    Ensure the product‚Äôs quality


8. What is a Sprint in Agile? What is Scrum Meeting?

Sprint: A short, time-boxed period (usually 2‚Äì4 weeks) in which a specific set of features is developed and tested.

Scrum Meeting: A daily stand-up meeting (15 mins) to discuss progress, blockers, and next steps.


9.Explain about Kanban Board?

A Kanban Board is a visual tool used in Agile to track workflow.
It has columns like To Do ‚Üí In Progress ‚Üí Testing ‚Üí Done.
It helps teams visualize tasks, limit work in progress, and improve flow efficiency.



10.What is V-model?

The V-model is a software development model that emphasizes verification and validation.

The V-Model (Verification and Validation model) is an extension of the Waterfall model.
Each development phase has a corresponding testing phase arranged in a ‚ÄúV‚Äù shape.

Example:

Requirement ‚Üî Acceptance Testing

Design ‚Üî Integration Testing

Coding ‚Üî Unit Testing


11. Difference between Blackbox and Whitebox Testing:
Blackbox tests functionality without seeing internal code.
Whitebox tests internal logic and code structure.
Blackbox = User perspective; Whitebox = Developer perspective.

12. What is Non-Functional Testing? Give some examples:

Non-Functional Testing checks performance, usability, security, and reliability.
It ensures the system‚Äôs behavior under specific conditions.
Examples: Load Testing, Stress Testing, Security Testing.

13. Explain the significance of Integration Testing:
Integration Testing checks data flow and interaction between modules.
It ensures combined modules work together properly.
It helps catch interface and communication defects early.

14. Browser and Device Testing Scenario:
Testing a site on different browsers or devices is Compatibility Testing.
It ensures the application works consistently across environments.
Finding a defect in iPhone 6 means device compatibility issue.

15. Define Accessibility Testing and its importance:
Accessibility Testing ensures the application is usable by people with disabilities.
It checks screen readers, color contrast, and keyboard navigation.
It promotes equal access and compliance with accessibility standards.

16. Navigate to this page https://www.saucedemo.com and  Write Testcase for Products page.

Test Case ID: TC_001

Test Case Description: Verify product list is displayed correctly on Products page.

Precondition: User logged in successfully.

Test Steps: Navigate to Products page ‚Üí Check product images, names, and prices.

Expected Result: All products display with correct image, name, and price details.

Status: Pass/Fail



17.What is Domain Requirements? Explain with examples.

Domain Requirements define business-specific rules and logic for the application.
They describe how the software should behave in a particular industry.

Example: In Banking ‚Äî Interest calculation; 
         In E-commerce ‚Äî Cart and Payment flow

18. Benefits of RTM?

RTM ensures complete test coverage by linking requirements to test cases.
It helps track missing or untested functionalities easily.
It provides clear traceability from requirement to defect closure.



19.Prepare a sample RTM document for E-commerce / Banking application ?

 Sample 
 RTM (E-commerce):

| Req ID | Requirement | Test Case ID | Status | Defect ID |
| R001   | User Login  | TC_001       | Passed | -         |
| R002   | Add to Cart | TC_005       | Failed | D_002     |
| R003   | Payment     | TC_010       | Passed | -         |

20. What are all the Entry criteria needed to start Testing?

Approved test plan, test cases, stable build, test environment ready.

21. What are all the deliverables you provide to stake holder after test completion?

Test Summary Report, Defect Report, RTM, Closure Report.

22.What are all the factors need to confirm that your System Testing is complete? 

All test cases executed, major bugs fixed, exit criteria met.

23. Test Execution Report is the deliverable for Entry criteria or Exit criteria? Give reason for the same.

Test Execution Report ‚Üí Exit Criteria: Because it‚Äôs shared after execution to confirm test completion.

24. Coding Standards

Set of guidelines for writing clean, consistent, and readable code.

Includes naming conventions, indentation, comments, and file structure.

Improves maintainability and reduces debugging effort.

Ensures all team members follow the same coding style.

Enhances code quality and reduces chances of defects.

25. Benefits of Static Testing

Detects defects early without executing the code.

Finds syntax errors, design flaws, and coding standard violations.

Reduces cost and effort by preventing late-stage defects.

Improves code quality, readability, and maintainability.

Enhances overall reliability and security of the application.

26. Explain about Boundary Value Analysis and Write a test case for that ?

Boundary Value Analysis (BVA)

Technique to test values at the boundaries of input ranges.

Defects often occur at the minimum, maximum, just below, and just above limits.

Focuses on edge values rather than full range.

Example Requirement: Age must be between 18 and 60.

BVA Test Cases:

17 ‚Üí Invalid

18 ‚Üí Valid

19 ‚Üí Valid

60 ‚Üí Valid

61 ‚Üí Invalid

27.  Explain about Equivalence Partitioning and Write a test case about that ?

Technique that divides input data into valid and invalid classes.

From each partition, only one representative test value is enough.

Reduces total test cases while maintaining good coverage.

Example Requirement: Age must be between 18 and 60.

EP Test Cases:

Invalid partition (<18): 10

Valid partition (18‚Äì60): 30

Invalid partition (>60): 75


28.Difference between State Transition Testing and Use Case Testing?


State Transition Testing: Focuses on system behavior when moving from one state to another based on events/inputs.

Use Case Testing: Focuses on user interactions and end-to-end flows based on functional requirements.

State Transition checks valid/invalid transitions; Use Case checks real user scenarios.

State Transition is event-driven; Use Case is goal-driven.

State Transition uses diagrams/tables; Use Case uses narratives and actors.



29.

Use Case Diagram ‚Äì Banking System (Textual Representation)

Actors:

User

Admin

User Use Cases:

Register

Login

Check Balance

Transfer Funds

Admin Use Cases:

Register

Login

Delete Account

Update Account


          +------------------------+
          |      Banking System    |
          +------------------------+
User -----------------> (Register)
User -----------------> (Login)
User -----------------> (Check Balance)
User -----------------> (Transfer Funds)

Admin ----------------> (Register)
Admin ----------------> (Login)
Admin ----------------> (Delete Account)
Admin ----------------> (Update Account)



30. State Transition Testing (Explanation + Example Table)

State Transition Testing checks how the system behaves when moving between different states based on user actions.

Useful when the application's response depends on previous state (e.g., login flows, shopping carts, banking).

Ensures valid transitions work and invalid transitions trigger proper errors.

Example: Shopping Site ‚Äì Add to Cart & Checkout Flow

States:

S1: Not Logged In

S2: Logged In

S3: Item Added to Cart

S4: Checkout Completed

Events:

E1: Login

E2: Add Item

E3: Checkout

E4: Logout


| Current State      | Event    | Next State         | Expected Result                   |
| ------------------ | -------- | ------------------ | --------------------------------- |
| Not Logged In      | Login    | Logged In          | User successfully logged in       |
| Logged In          | Add Item | Item Added to Cart | Item added to cart                |
| Item Added to Cart | Checkout | Checkout Completed | Order placed successfully         |
| Item Added to Cart | Logout   | Not Logged In      | Cart cleared; user logged out     |
| Not Logged In      | Checkout | Not Logged In      | Error: Must login before checkout |
| Logged In          | Checkout | Logged In          | Error: Cart empty                 |



31.Write 3 examples explaining about White Box Testing.


Three Examples of White Box Testing

Example 1 ‚Äì Code Coverage Testing

Verifying all statements, branches, and conditions are executed.

Example: Ensuring all if‚Äìelse paths in a login function are tested.

Example 2 ‚Äì Loop Testing

Checking loop entry, exit conditions, and boundary iterations.

Example: Validating a for loop that processes 1‚Äì10 items runs correctly for 0, 1, 10, and 11 items.

Example 3 ‚Äì Path Testing

Ensuring every unique path through the code logic is executed once.

Example: Testing all possible paths in a payment validation method.


32. Prepare a small diagram / table about white box testing.

| Technique          | Purpose                           | Example                           |
| ------------------ | --------------------------------- | --------------------------------- |
| Statement Coverage | Execute all lines of code         | Test all login validations        |
| Branch Coverage    | Execute all branches (true/false) | Test both valid/invalid OTP flows |
| Path Coverage      | Execute all logical paths         | Payment routing logic             |
| Loop Testing       | Validate loops and boundaries     | Iterating cart items              |


33. Summarize key challenge and solutions related to White Box Testing.

Challenges:

Requires deep programming knowledge.

Hard to test large, complex code structures.

Time-consuming due to many paths & branches.

Maintenance effort increases with code changes.

Solutions:

Use tools like JaCoCo, JUnit, SonarQube for coverage automation.

Break code into smaller modular functions.

Follow coding standards to reduce complexity.

Maintain updated documentation of code logic.


34. Create at least 2 Testcase demonstrating White Box Testing.

Test Case 1 ‚Äì Branch Coverage for Login Function

Code Under Test

if(username == null) return "Invalid";
if(password == null) return "Invalid";
if(username.equals("admin") && password.equals("123")) return "Success";
else return "Failed";


Test Case

TC ID	Input (username, password)	Execution Goal	Expected Output
TC01	null, "123"	Cover null username	Invalid
TC02	"admin", null	Cover null password	Invalid
TC03	"admin", "123"	True branch success	Success
TC04	"admin", "999"	False branch failure	Failed


Test Case 2 ‚Äì Loop Testing for Cart Calculation

Code Under Test (Simplified)

int sum = 0;
for(int i=0; i<items.length; i++){
   sum += items[i];
}
return sum;


Test Case

TC ID	Input (items array)	Loop Behavior Tested	Expected Output
TC01	[]	Loop runs 0 times	                0
TC02	[100]	Loop runs once	                100
TC03	[10,20,30]	Loop runs multiple times	60


35. Difference Between Experience-Based Testing and Formal Testing
Experience-Based Testing? 


Relies on tester‚Äôs knowledge, intuition, and past project experience.


Useful when documentation is limited or time is short.


Detects practical, real-world defects quickly.


Examples: Error Guessing, Exploratory Testing.


Formal Testing:


Follows structured processes, documentation, and predefined test cases.


Based on requirements, standards, and coverage criteria.


Ensures systematic, measurable, and traceable testing.


Examples: Boundary Value Analysis, Equivalence Partitioning, State Transition Testing.




36. Explain in detail about Defect Reporting and its sample template.


Defect reporting is the process of logging issues found during testing with complete evidence.

Its goal is to help developers reproduce, analyze, and fix defects quickly.

A good report is clear, concise, reproducible, and includes environment details.


| Field                | Description / Example                                      |
|----------------------|------------------------------------------------------------|
| Defect ID            | DEF-2025-001                                               |
| Title                | Login button click not triggering authentication           |
| Severity / Priority  | Critical / High                                            |
| Environment          | QA Env / Chrome 120 / Windows 10                           |
| Steps to Reproduce   | 1. Navigate to login page                                  |
|                      | 2. Enter valid username and password                       |
|                      | 3. Click on the Login button                               |
| Expected Result      | User should be logged into the dashboard                   |
| Actual Result        | Login button is unresponsive; no action occurs             |
| Attachments          | login_button_issue.png / console_error_log.txt             |




37. Difference between Not a Defect and Duplicate Defect. Give some examples.


Not a Defect: Behavior is correct as per requirement; tester misunderstood the functionality.

Example: Requirement says ‚ÄúPassword must auto-expire after 60 days‚Äù ‚Üí Tester reports it as bug; dev marks it ‚ÄúNot a defect‚Äù.


Duplicate Defect: Same issue already exists in the defect tracker.

Example: Two testers raise the same login crash issue ‚Üí second one marked ‚ÄúDuplicate‚Äù.

Key Difference: Validity (Not a Defect) vs Redundancy (Duplicate).





38. What will be the status of defect when the developer accepts the defect and starts to work on it?


Status becomes ‚ÄúIn Progress‚Äù.

This indicates the developer has acknowledged the defect.

Work has started on analyzing and applying the fix.

It moves out of the Open/Assigned state.

Used to showcase active development on the issue.



39.If a tester tests the fix of a defect and found that it is not fixed. He will change the defect status to which state and why?


Tester changes status to ‚ÄúReopen‚Äù.

Reason: The expected fix is not working or issue still reproducible.

Reopened defects go back to the developer for re-fixing.

Indicates failed retesting.

Ensures defect lifecycle loops properly.



40.Difference between Defect and Failure with examples. 

	Defect: A flaw in the software that causes it to behave unexpectedly.
	
	Example: A missing validation on email format in registration form.
			
	Failure: When the software does not perform as expected during execution.
			
	Example: Application crashes when user submits invalid email format.
	
	Key Difference: Defect is the root cause; Failure is the observable effect.		
	

41. Explain about Test Metrics with examples.

 Test Metrics are quantitative measures used to assess the quality and effectiveness of the testing process.
 
 They help track progress, identify bottlenecks, and improve testing strategies.
 
 Examples:
 
 Defect Density: Number of defects per size of the software (e.g., per 1000 lines of code).		
 Test Case Execution Rate: Percentage of test cases executed over total planned test cases.
 Test Pass Rate: Percentage of test cases that passed successfully.
 Defect Resolution Time: Average time taken to fix reported defects.
 Test Coverage: Percentage of requirements or code covered by test cases.
 
 
42. Explain about different types of metrics.
There are several types of test metrics used to evaluate different aspects of the testing process:

1. **Product Quality Metrics**: Measure the quality of the software product itself.

   - Example: Defect Density, Defect Leakage.

2. **Process Metrics**: Evaluate the efficiency and effectiveness of the testing process.

   - Example: Test Case Execution Rate, Test Pass Rate.
   
3. **Project Metrics**: Track the progress and status of the testing project.
   
   - Example: Test Completion Percentage, Defect Resolution Time.
   			

 
 42. Explain about Test Plan and its template.
 	
 	A Test Plan is a formal document that outlines the testing strategy, objectives, resources, schedule, and scope for a software project.
 
 	It serves as a roadmap for the testing team and stakeholders to ensure all aspects of testing are covered.
 	
 	Test Plan Template:
 	------------------------------------------------------------------------------
 	| Section               | Description                                        | 	
 	|-----------------------|----------------------------------------------------|
 	| Test Plan ID          | Unique identifier for the test plan                |
 	| Introduction          | Overview of the project and testing objectives     |
 	| Scope                 | Features to be tested and out of scope             |
 	| Test Strategy         | Overall approach to testing (types, levels)        |
 	| Test Environment      | Hardware, software, and network configurations     |
 	| Test Schedule         | Timeline for testing activities                    |
 	| Resources             | Team members, tools, and other resources needed    |
 	| Deliverables          | Documents and reports to be produced               |
 	| Risks and Mitigation  | Potential risks and their mitigation strategies    |
 	| Approval              | Sign-off from stakeholders                         |
 	-----------------------------------------------------------------------------	
 		
		 			
43. Explain about Test Strategy and its template.	
		 			
A Test Strategy is a high-level document that defines the testing approach, objectives, resources, and schedule for a software project.
It provides a framework for the testing process and ensures alignment with project goals.

Test Strategy Template:
---------------------------------------------------------------------------------------------
| Section               | Description                                                        |
|-----------------------|--------------------------------------------------------------------|
| Test Strategy ID      | Unique identifier for the test strategy                            |
| Introduction          | Overview of the project and testing objectives                     |
| Testing Objectives    | Goals and objectives of the testing effort                         |
| Test Levels           | Different levels of testing (unit, integration, etc.)              |
| Test Types            | Types of testing to be performed (functional, non-functional, etc.)|
| Test Environment      | Hardware, software, and network configurations                     |
| Test Tools            | Tools and technologies to be used                                  |
| Test Schedule         | Timeline for testing activities                                    |
| Resources             | Team members, tools, and other resources needed                    |
| Risks and Mitigation  | Potential risks and their mitigation strategies                    |
| Approval              | Sign-off from stakeholders                                         |
---------------------------------------------------------------------------------------------
 			
 					


44.  What is Risk-Based Testing and when will you use that?

Risk-Based Testing (RBT) is a testing approach that prioritizes testing efforts based on the risk of failure and its potential impact on the project.
It focuses on identifying high-risk areas and allocating resources to test those areas more thoroughly.

When to use RBT:
	
When project timelines are tight and resources are limited.

When certain features or components are critical to business operations.

When there is a history of defects in specific areas of the application.

When regulatory compliance or security is a concern.

When testing complex systems with many interdependencies.


45.


